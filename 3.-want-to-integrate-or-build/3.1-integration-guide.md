# Integration Guide

We invite wallet teams and dApp devs to integrate with Incognitee to enhance privacy for their users. This guide will help you get started.

## Rust API

Please check our [cli client code](https://github.com/integritee-network/worker/tree/master/cli) with many demo scripts to learn how to interact with the Incognitee API using Rust.

## Javascript API

The following sample code shows you how to perform the most common actions using the Incognitee API. The relevant library comes in typescript, so we encourage you to use typescript even if this example is js. 

To run it, do:

```bash
nvm use 20
yarn add @encointer/worker-api
node index.js
```

index.js:
```javascript
// A simple sample code for common use cases of the Incognitee API

const {IntegriteeWorker} = require("@encointer/worker-api");
const {Keyring} = require("@polkadot/keyring");
const {cryptoWaitReady, mnemonicToMiniSecret} = require("@polkadot/util-crypto");
const {hexToU8a} = require("@polkadot/util");
const bs58 = require("bs58");

// Adjust these for the shard you'd like to use
const INCOGNITEE_SHARD = "5wePd1LYa5M49ghwgZXs55cepKbJKhj5xfzQGfPeMS7d";
const INCOGNITEE_URL = "wss://scv1.paseo.api.incognitee.io:443";

async function main() {

    // Initialize the Incognitee API
    const api = new IntegriteeWorker(INCOGNITEE_URL);

    // Wait for crypto to be ready
    await cryptoWaitReady();

    // PublicGetters need no signature, they can be queried by anyone
    const info = await api.parentchainsInfoGetter(INCOGNITEE_SHARD).send();
    console.log("[PublicGetter] Parentchains Info:")
    console.log(info.toHuman());

    const localKeyring = new Keyring({type: "sr25519", ss58Format: 42});
    const account = localKeyring.addFromUri('//Alice', {
        name: 'Alice',
    });

    // Make sure Alice is funded or use your own account instead:
    // 1. visit app.incognitee.io/pas
    // 2. create test account
    // 3. shield PAS to incognitee
    // 4. copy seed from url and insert it below

    // const account = localKeyring.addFromSeed("<seed>");

    // You could send funds to the shard_vault if you want to shield without using our dApp at app.incognitee.io/pas.
    // Note: Do **NOT** send funds from a centralized exchange, you need to have the private key to access your shielded funds!!!
    const shard_vault = await api.getShardVault()
    console.log("Send PAS to this shard vault on L1 for shielding: " + shard_vault.toString());

    // querying balance needs authentication (privacy!)
    const getter = await api.accountInfoAndSessionProxiesGetter(account, INCOGNITEE_SHARD);

    const response = await getter.send();
    console.log("[TrustedGetter] Account's free balance: " + response.toHuman().account_info.data.free);
    // check if a session proxy has been defined previously
    console.log("[TrustedGetter] Previously defined session proxy?:");
    console.log(response.toHuman().session_proxies[0]);

    // transfer funds privately on L2 to Bob
  
    // The fingerprint let's us verify the business logic if we want.
    const fingerprint_hex = await api.getFingerprint();
    const fingerprint = bs58.encode(hexToU8a(fingerprint_hex.toString()));
    console.log("[TrustedCall] using enclave fingerprint:" + fingerprint);
    
    const bob = "5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty"

    // send funds to Bob
    await api.trustedBalanceTransfer(
        account,
        INCOGNITEE_SHARD,
        fingerprint,
        account.address,
        bob,
        100000000,
        "hello world"
    )

    // send a message to Bob
    await api.trustedSendNote(
        account,
        INCOGNITEE_SHARD,
        fingerprint,
        account.address,
        bob,
        "Hi Bob"
    )

    // unshield funds to L1 to Bob's account
    await api.balanceUnshieldFunds(
        account,
        INCOGNITEE_SHARD,
        fingerprint,
        account.address,
        bob,
        100000000
    )

    // Register a session proxy: let delegate sign on behalf of account, but only for non-transfer actions and queries.
    // See chapter 5 for more information on session proxies.
    const delegateMiniSecret = mnemonicToMiniSecret("secret forest ticket smooth wide mass parent reveal embark impose fiscal company");
    const delegate = localKeyring.addFromSeed(delegateMiniSecret);

    await api.trustedAddSessionProxy(
        account,
        INCOGNITEE_SHARD,
        fingerprint,
        api.createType('SessionProxyRole', 'NonTransfer'),
        delegate.address,
        null,
        delegateMiniSecret
    )

    // now we can query the account balance using the delegate
    const res = await api.getAccountInfo(
        account.address, // we only pass the address here. no need to know the secret
        INCOGNITEE_SHARD,
        {delegate: delegate} // the delegate account will be used for signing
    )
    console.log("Account's free balance fetched using session proxy: " + res.toHuman().data.free);

    // or we can fetch recent messages and tx history for the account
    // first we fetch note buckets info:
    const noteBucketsInfoGetter = await api.noteBucketsInfoGetter(INCOGNITEE_SHARD);
    const noteBuckets = await noteBucketsInfoGetter.send();
    const lastBucket = noteBuckets.toHuman().last.index
  
    // then we create a reusable getter which we can poll regularly to check for new messages
    const notesGetter = await api.notesForTrustedGetter(
        account.address,
        lastBucket,
        INCOGNITEE_SHARD,
        {delegate: delegate}
    )
    // send getter each time you want to poll for new messages
    const notes = await notesGetter.send();
    console.log("Messages and TX history for account:");
    for (const note of notes) {
        if (note.note.isSuccessfulTrustedCall) {
          const call = api.createType(
            "IntegriteeTrustedCall",
            note.note.asSuccessfulTrustedCall,
          );
          console.log("Call: ", call.toHuman());
        }
    }
    
    // bye bye
    api.closeWs()
}

main();
```
